<!DOCTYPE html>
<html>

<head>

    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <link rel="stylesheet" type="text/css" href="style.css">
    <title>Web Services frameworks for Sabre API</title>
</head>

<body>

    <!-- Index of content -->

    <span class="header"> Index of content </span>
    <ul>
        <li><a href="#overview-anchor">Overview</a></li>
        <li>
            <span class="bold"><a href="#db-frameworks-anchor">Java data binding frameworks</a></span>
            <ul>
                <li>
                    <a href="#jaxb-anchor">JAXB</a>
                </li>
                <li>
                    <a href="#adb-anchor">Apache ADB</a>
                </li>
                <li>
                    <a href="#xmlbeans-anchor">Apache XMLBeans</a>
                </li>
            </ul>
        </li>
        <li>
            <span class="bold"><a href="#ws-frameworks-anchor">Java web services frameworks</a></span>
            <ul>
                <li>
                    <a href="#wsimport-framework-anchor">wsimport</a>
                </li>
                <li>
                    <a href="#cxf-framework-anchor">Apache CXF</a>
                </li>
                <li>
                    <a href="#axis2-framework-anchor">Apache Axis2</a>
                </li>
                <li>
                    <a href="#spring-ws-framework-anchor">Spring Web Services</a>
                </li>

            </ul>
        </li>
    </ul>


    <!-- Overview & intro -->

    <a name="overview-anchor"></a>
    <span class="header">Overview</span>
    <p>
        This document describes some of the popular frameworks and tools for creating web services applications and
        binding data and compares their suitability to work with Sabre API. There is also a brief
        guide on how to use each framework to build Sabre API client application and a list of
        problems that one may encounter when developing it. To see the working sample implementation of Sabre API client in each described technology, please refer to <a href="sample_client_documentation.html">sample project</a> supplied by SOAP API team. It may be used as an example on how to use each framework or an application template.

        <br /><br/>
    </p>

<!-- Document content -->

    <!-- Data binding frameworks -->

    <a name="db-frameworks-anchor"></a>
    <span class="header">Data binding frameworks</span><br /><br />

    <!-- JAXB -->

    <a name="jaxb-anchor"></a> <!-- Framework name -->
    <span class="subheader">JAXB</span><br /><br />
    <div class="intend-level-1">

        <!-- Overview -->
        <a name="jaxb-overview-anchor"></a>
        <span class="bold"> Overview </span><br/>
        <p>
            JAXB data binding is a powerful tool with good customization capabilities, due to custom bindings mechanism.
            Thanks to that, if default behavior causes any problems, it may be easily changed. JAXB is a commercial standard
            for Java XML binding and is a recommended tool for working with Sabre API.
        </p>

        <!-- Using -->
        <a name="jaxb-using-anchor"></a>
        <span class="bold"> Using </span><br/>
        <p>
            The main ability of JAXB, creating Java classes from XSD schemas, is available through
            <span class="code">xjc</span> schema compiler, which may be accessed in a variety of ways. <br />
            Firstly, it is distributed as stand-alone command line tool with JDK since version 6. To use it this way,
            just type <span class="code">xjc path/to/schema/file.xsd [-options]</span>. To see full list of xjc command line tool
            options, check <a href="https://jaxb.java.net/2.2.4/docs/xjc.html">XJC documentation</a>.<br />

            When using JAXB as data binding framework to work with Apache CXF, it is generally advised to use
            <span class="code">cxf-codegen-plugin</span> maven plugin with proper binding option. <br />

            <br />
            <span class="code">xjc</span> is also available as JAXB maven plugins:
        </p>
        <ul>
            <li class="code">
                &emsp;&emsp;&lt;groupId&gt;org.jvnet.jaxb2.maven2&lt;/groupId&gt;<br />
                &emsp;&emsp;&lt;artifactId&gt;maven-jaxb2-plugin&lt;/artifactId&gt;<br /><br />
            </li>
            <li class="code">
                &emsp;&emsp;&lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;<br />
                &emsp;&emsp;&lt;artifactId&gt;jaxb2-maven-plugin&lt;/artifactId&gt;<br /><br />
            </li>
        </ul>
        <p>
            The use of both is similar, and details are available at
            <a href="https://java.net/projects/maven-jaxb2-plugin/pages/Home">java.net</a> and
            <a href="http://mojo.codehaus.org/jaxb2-maven-plugin/index.html">mojo</a> websites.
        </p>

        <!-- Execution requirements -->
        <a name="jaxb-execution-requirements-anchor"></a>
        <span class="bold"> Execution requirements </span><br/>
        <p>
            Just like with other data bindings, the main and only requirement is to provide all necessary files
            and their directories. This includes services definitions (WSDL files) and XSD schema definitions for
            data types used in SOAP communication. Both types of resource are available at <a href="http://developer.sabre.com">Sabre&reg; Dev Studio</a>.

            In this case, along with schemas and WSDL files, custom bindings (in form of .jxb files) should
            be delivered (via proper execution parameter). <br /><br />

            Some of Sabre API will require specyfing custom JAXB binding file during schema compilation. This is
            because some schemas contain nested types with the same name as one of outer elements. JAXB compiles each
            complex type into a public static inner class and there cannot be two such classes with the same name.
            However, this may solved easily. The custom binding file has a form of a XML file (although the file
            extension may be different, like <span class="code">*.jxb</span>, to emphasize it's function) and the following structure:
        </p>

        <p>
            <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table style="color: black;"><tr><td><pre style="margin: 0; line-height: 125%">1
2
3
4
5
6
7
8</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #557799">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;</span>
<span style="color: #007700">&lt;jaxb:bindings</span> <span style="color: #0000CC">version=</span><span style="background-color: #fff0f0">&quot;2.0&quot;</span> <span style="color: #0000CC">xmlns:jaxb=</span><span style="background-color: #fff0f0">&quot;http://java.sun.com/xml/ns/jaxb&quot;</span> <span style="color: #0000CC">xmlns:xjc=</span><span style="background-color: #fff0f0">&quot;http://java.sun.com/xml/ns/jaxb/xjc&quot;</span> <span style="color: #0000CC">xmlns:xs=</span><span style="background-color: #fff0f0">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span style="color: #0000CC">xmlns:wsdl=</span><span style="background-color: #fff0f0">&quot;http://schemas.xmlsoap.org/wsdl/&quot;</span><span style="color: #007700">&gt;</span>
  <span style="color: #007700">&lt;jaxb:bindings</span> <span style="color: #0000CC">schemaLocation=</span><span style="background-color: #fff0f0">&quot;hardcoded/path/to/schema/file.xsd&quot;</span> <span style="color: #0000CC">node=</span><span style="background-color: #fff0f0">&quot;/xs:schema&quot;</span><span style="color: #007700">&gt;</span>
    <span style="color: #007700">&lt;jaxb:bindings</span> <span style="color: #0000CC">node=</span><span style="background-color: #fff0f0">&quot;XPath_expression_of_node_being_customized&quot;</span><span style="color: #007700">&gt;</span>
      <span style="color: #007700">&lt;jaxb:class</span> <span style="color: #0000CC">name=</span><span style="background-color: #fff0f0">&quot;CustomizedClassName&quot;</span> <span style="color: #007700">/&gt;</span>
    <span style="color: #007700">&lt;/jaxb:bindings&gt;</span>
  <span style="color: #007700">&lt;/jaxb:bindings&gt;</span>
<span style="color: #007700">&lt;/jaxb:bindings&gt;</span>
</pre></td></tr></table></div>

        </p>

        <p>
            One can use this template to create custom bindings. It requires specifying 3 things:
        </p>

        <ul>
            <li>Location of a schema file (if this does not match with the location of the file being compiled, error will occur) </li>
            <li>XPath expression of a node whose name will be customized</li>
            <li>Customized class name to bind node to</li>
        </ul>

        <!-- Generated Code -->
        <a name="jaxb-generated-code-anchor"></a>
        <span class="bold"> Generated code </span><br/>
        <p>
            By default, JAXB will generate classes <span class="italic">per namespace</span>, mapping <span class="code">targetNamespace</span>
            attribute from schema to package name. For example, type <span class="code">PassengerDetailsRQ</span>, defined in
            <span class="code">http://webservices.sabre.com/sabreXML/2011/10</span> target namespace will be compiled (with
            default settings) to <span class="code">com.sabre.webservices.sabrexml._2011._10.PassengerDetailsRQ</span> class.
            This means no class duplication and the ability to reuse the code throughout the application. JAXB generates nested public
            static classes to reflect the structure of a schema. Bindings of nodes and package names may be customized using binding files
            (<a href="https://jaxb.java.net/guide/Customizing_Java_packages.html">Check JAXB's section on Metro Project web page</a> for hints about package naming customization). <br /><br />

            The classes will be annotated with JAXB annotations, which means they may be reused by any other JAX-WS implementation.
            Because it is a widely used standard, it makes the code more generic, reusable and less tightly-coupled
        </p>

        <!-- Known Issues -->
        <a name="jaxb-known-issues-anchor"></a>
        <span class="bold"> Summary </span><br/>
        <p>
            Currently, there are no major issues concerning the use of CXF/JAXB tools with Sabre API, that can't be solved
            with a little or no effort (which usually boils down to creating custom binding file).
            Therefore, <span class="reccommended"> JAXB is a recommended data binding tool to work with Sabre API in Java language.</span>
        </p>

    </div>

    <!-- ADB -->

    <a name="adb-anchor"></a> <!-- Framework name -->
    <span class="subheader"> Apache ADB </span>
    <div class="intend-level-1">

        <!-- Overview -->
        <a name="adb-overview-anchor"></a><br />
        <span class="bold"> Overview </span><br/>
        <p>
            ADB data binding framework is intended to be rather simple and lightweight. It provides means to compile XML schemas and WSDL files into java classes.
            Use of this tool is pretty straightforward, but working with generated files may be cumbersome.
        </p>

        <!-- Using -->
        <a name="adb-using-anchor"></a>
        <span class="bold"> Using </span><br/>
        <p>
            ADB data binding is generally available through the <span class="code">WSDL2Java</span> tool, by specifying proper databinding option, as described
            in Axis2 section <!-- TODO: add link -->.
        </p>

        <!-- Execution requirements -->
        <a name="adb-execution-requirements-anchor"></a>
        <span class="bold"> Execution requirements </span><br/>
        <p>
            As Sabre API definitions (provided in the form of WSDL files) use corresponding types and data
            structures, proper XML Schema files must be provided in the same location as the WSDL file.
            It includes common schemas for SOAP communication protocol and request/response object pairs definition
            (available at <a href="http://developer.sabre.com">Sabre&reg; Dev Studio</a>).
        </p>

        <!-- Generated Code -->
        <a name="adb-generated-code-anchor"></a>
        <span class="bold"> Generated Code </span><br/>
        <p>
            If all of the required files are available for code generation tool, after invocation it will by default generate one
            stub java class per service.
            The file will be placed in proper folder structure, according to specified output package and directory.
            The file will be named <span class="code"> &lt;serviceName&gt;ServiceStub.java</span>.
            The stub will contain static inner classes for each complex type. Any element or attribute encapsulated by this complex type
            will become a field in that class. Simple types restrictions are handled by replacing the relevant type with the basetype.
            Generated classes follow the bean convention, with <span class="code">setAttribute</span> and
            <span class="code">getAttribute</span> methods for object fields and
            <span class="code">addElement(Element e)</span> or <span class="code">setElements(Element [] e)</span> for arrays.

        </p>

        <!-- Known Issues -->
        <a name="adb-known-issues-anchor"></a>
        <span class="bold"> Summary </span><br/>
        <p>
            Beacuse all used structures are compiled into a stub class as static innter classes, the generated
            files may be quite large (up to hundreds of thousands of lines, depending on service definition
            complexity) and therefore problematic to work with, for example some IDE settings changes may be necessary. <br />
            What is more, ADB does not handle optional attributes in schema definitions well. In generated SOAP messages optional
            attributes are always present, with values set to their defaults, which may not be desired behavior. In particular cases
            optional attributes may be mutually exclusive and sending request containing them to server may cause the server
            to respond with Fault message. <br />
            Therefore it might not be possible to use automatically generated code without modificating it manually. <br /><br />
            Nevertheless, using ADB causes significant code redundancy in project. The reason is the fact that all binding inner
            classes are generated per service. So there is one inner class for eb:MessageHeader xml object and one for wsse:Security
            in each service, even though the structure of these classes is identical, as they reflect the same source xml structure.
            For each service request an object of those classes must be assembled. So either a separate header-creating method must
            be implemented for each service stub causing code repetition, or a header factory method using reflection
            and generic return type may be introduced, which would be difficult and error-prone. <br/><br />
            Because of the facts mentioned above, <span class="warning">ADB is not a recommended databinding framework
            for working with Sabre API.</span>
        </p>

    </div>

    <!-- XMLBeans -->

    <a name="xmlbeans-anchor"></a> <!-- Framework name -->
    <span class="subheader">XMLBeans</span><br /><br/>
    <div class="intend-level-1">

        <!-- Overview -->
        <a name="xmlbeans-overview-anchor"></a>
        <span class="bold"> Overview </span><br/>
        <p>
            XMLBeans is another data binding framework for Java. It also is available via <span class="code">wsdl2code</span> maven plugin.
            In this case, classes are not generated per service, but rather per namespace. It eliminates the code duplication problem,
            causing code to be clearer and easier to use. <br />
            However, XMLBeans framework has another significant problem, which may cause it impossible to use with some of the
            Sabre API (described in separate section). One should keep that in mind when deciding to use XMLBeans,
            because at some point being unable to consume specific Sabre&reg; Web Service may block development of whole application.
        </p>

        <!-- Using -->
        <a name="xmlbeans-using-anchor"></a>
        <span class="bold"> Using </span><br/>
        <p>
            Just like ADB, XMLBeans data binding is available in Axis2 and CXF via <span class="code">WSDL2Java</span> command line tool
            or <span class="code">wsdl2code</span> Maven plugin in Axis2 or <span class="code">cxf-codegen-plugin</span>
            in CXF. They both provide same functionality and require similar configuration. <br /><br />

            To read about using XMLBeans binding from command line, go to
            <a href="http://cxf.apache.org/docs/wsdl-to-java.html">WSDL 2 Java section on CXF website</a>.<br />
            Maven plugin is described in <a href="http://cxf.apache.org/docs/maven-cxf-codegen-plugin-wsdl-to-java.html">
            it's own section</a> of that site.
        </p>

        <!-- Execution requirements -->
        <a name="xmlbeans-execution-requirements-anchor"></a>
        <span class="bold"> Execution requirements </span><br/>
        <p>
            When using XMLBeans framework , the flow is similar to the one described in ADB section. The main
            (and in most cases, the only) change would be to change the data binding option
            (the <span class="code">-d xmlbeans</span> command line option or
            <span class="code">&lt;databindingName&gt;xmlbeans&lt;/databindingName&gt;</span> in Maven configuration).
            Any additional files referenced from WSDL file must reside with it in it's directory.
        </p>

        <!-- Generated Code -->
        <a name="xmlbeans-generated-code-anchor"></a>
        <span class="bold"> Generated code </span><br/>
        <p>
            Unlike ADB, XMLBeans will generate classes per XML structure's namespace, which means one class for
            <span class="code">eb:MessageHeader</span> and
            one class for <span class="code">wsse:Security</span>. Creating these objects can be done globally and the
            proper factory method may be reused in every service. <br /><br />

            The structure of generated classes will mirror the structure of XSD schema definition. Each nested type
            in schema will cause the creation of corresponding nested Java Interface. That will cause problem described in the next section.
            <br /><br />

            Generated interfaces will be placed in a package whose name will reflect the target namespace of schema definition.
            The general rules for converting namespace to package name can be obtained from
            <a href="http://xmlbeans.apache.org/docs/2.0.0/guide/conJavaTypesGeneratedFromUserDerived.html">XMLBeans documentation</a>.<br /><br />

            XMLBeans maps schema types into JavaBeans-style classes. This means the presence of typical setter/getter methods, such as
            <span class="code">void setElement(ElementType element)</span> and <span class="code">ElementType getElement()</span>.
            One useful thing is also a <span class="code">ElementType addNewElement()</span> method, that creates new element, places
            it in the object in which it was invoked and returns it allowing further modification and processing. <br /> <br />

            One can learn about using XMLBeans at <a href="http://xmlbeans.apache.org/documentation/index.html">XMLBeans Project's website</a>
        </p>

        <!-- Known Issues -->
        <a name="xmlbeans-known-issues-anchor"></a>
        <span class="bold"> Summary </span><br/>
        <p>
            Although using XMLBeans data binding results in more clear and easy-to-use code, it has a serious issue,
            which makes it almost impossible to use with some of the Sabre API. <br /> <br />

            To reflect the structure of XML Schema Definition, XMLBeans creates a series of nested interfaces.
            Each nested type will have a corresponding nested interface. The problem is, that at compile time the Java compiler
            creates separate <span class="code">.class</span> file for each class or interface. Nested classes will be compiled
            to a file whose name will be composed of the name of the outer class, concatenated with the name of the inner class
            with the dollar symbol ('$'). Classes nested in inner classes will be compiled to a file whose name will be composed of the
            names of all classes which are higher in the hierarchy, like
            <span class="code">OuterClass$InnerClass1$InnerClass2$...$InnerClass10$InnerClass11.class</span>.
            When generating classes from a complex schema with deeply nested types, generated class's name may exceed the 255
            characters limit imposed by most of the modern filesystems, used in both Windows and Unix-like systems
            (this limit is present in all of the following file systems: NTFS, FAT32, exFAT, ext3, ext4 and ZFS). This will
            make such nested class/interface impossible to compile, as the Java compiler will not be able to save compiled
            file on disk. There is no possibility to use any custom binding or change XMLBeans behavior in way that would
            allow generating Java stubs from deeply nested schemas. Therefore it is not possible to use XMLBeans with some of
            the Sabre API, that contain deeply nested schemas (e.g. EnhancedAirBook, PassengerDetailsRQ, TravelItineraryLLSRQ),
            when using any common file system. On the other hand, changing operating system or switching to niche filesystem
            just to use one particular XML binding framework (while there are many others) seems to be an exaggeration. <br /><br />

            <!--For the record, it should be mentioned that there is actually a way to use XMLBeans on any common filesystem
            and avoid long file names issue. However, it is a workaround that requires developing specialized tools,
            like custom compilers or Maven plugins, that should be next incorporated into application build process.
            The trick is, that JVM itself does not preserve the 255 characters identifier length limit (it uses
            it's own 65535 characters limit), so the only problem is a intermediate step of storing .class file on disk
            between compiling and loading class by a classloader. Therefore, avoiding this step, would solve the problem.
            There are at least two possible ways to do that. They both make use of the <span class="code">javax.tools</span>
            package. The first way is to create a custom dynamic in-memory java compiler, that would load a source code file
            from the disk, compile it in-memory and then provide means of instantiating object of compiled class via
            customized in-memory classloader. Another way is to compile problematic source code in-memory and redirect the output
            to byte arrays, which then would be used to create a JAR containing created classes. That way the storing phase would
            be omitted, as the only file written to filesystem would be the JAR, which holds no name limitations. <br />
            Although those ways seem to solve the problem (they were not tested), once again, creating custom compilers
            and classloaders does not seem to be an adequate way of solving a problem caused by wrong choice of
            data binding framework for web services application.<br/><br />-->

            Because of the facts mentioned above, <span class="warning">XMLBeans is not a recommended databinding framework
    for working with Sabre API neither.</span>
        </p>

    </div>

    <!-- Web Services frameworks -->
    <a name="ws-frameworks-anchor"></a>
    <span class="header">Web Services Frameworks</span> <br /><br/>


    <!-- wsimport framework-->

    <a name="wsimport-framework-anchor"></a>
    <span class="subheader">wsimport</span><br/><br/> <!-- Framework name -->
    <div class="intend-level-1">

    <!-- Overview -->
    <a name="wsimport-overview-anchor"></a>
    <span class="bold"> Overview </span><br/>
    <p>
        The <span class="code">wsimport</span> tool generates JAX-WS portable artifacts (services,
        service endpoint interfaces, fault exceptions, JAXB generated value types). It is distributed with JDK
        (from version 6). Beacuse it implements JAX-WS specification, using it is similar to using other JAX-WS
        implementation - CXF.
    </p>

    <!-- Using Framework -->
    <a name="wsimport-using-anchor"></a>
    <span class="bold"> Using </span><br/>
    <p>
        Using <span class="code">wsimport</span> is very simple and in many cases it would require no additional
        configuration - it should run from command line on any machine with JDK 6 or newer installed.
        To check if it is available (assuming that <span class="code">JAVA_HOME\bin</span> is in
        <span class="code">PATH</span> system variable), just type <span class="code">wsimport -help</span>.
        The <span class="code">wsimport</span> help page should be displayed. It contains information on
        how to use this tool. <br /><br />

        The simplest use case is compiling WSDL service definition into JAXB-generated classes. To do that,
        just type: <br /><br />

        <span class="code">wsimport -keep -verbose path/to/wsdl/file.wsdl</span> <br /><br />

        This will compile all schemas into java classes and create JAX-WS service artifacts for each service
        defined in WSDL file. <br /><br />

        <span class="code">wsimport</span> is also available as Maven plugin. To utilize it in your project,
        add the following to your POM's plugin section: <br /><br />
    </p>

    <p class="snippet">
        &lt;plugin&gt;<br />
        &emsp;&lt;groupId&gt;org.jvnet.jax-ws-commons&lt;/groupId&gt;<br />
        &emsp;&lt;artifactId&gt;jaxws-maven-plugin&lt;/artifactId&gt;<br />
        &lt;/plugin&gt;
    </p>

    <p>
        The detailed information about using wsimport from command line are available at
        <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/wsimport.html">Java SE Documentation page</a><br /><br />

        <span class="code">wsimport</span> Maven plugin is described in details in
        <a href="https://jax-ws-commons.java.net/jaxws-maven-plugin/wsimport-mojo.html">Metro project documentation</a>.
    </p>

    <!-- Typical flow in particular framework -->
    <a name="wsimport-typical-flow-anchor"></a>
    <span class="bold"> Typical flow </span><br/>
    <p>

    </p>

    <ol>
        <li>Collecting all necessary files (WSDL, XML and XSD) for each service</li>
        <li>Generating JAXB-annotated classes and other JAX-WS artifacts</li>
        <li>Developing client, which will use generated classes</li>
        <li>Providing SOAP handlers</li>
        <li>Invoking services via adequate methods calls</li>
        <li>Receiving and handling the response</li>
    </ol>

    <!-- Details of client development -->
    <a name="wsimport-developing-client-anchor"></a>
    <span class="bold"> Developing client in detail </span><br/>
    <p>
        Client development starts with invoking <span class="code">wsimport</span> tool on appropriate WSDL file
        (all service-specific and common schemas must be present in one directory).
        It will generate JAX-WS artifacts - JAXB classes (that represent data types used in messages being exchanged
        and are defined in schemas) and JAX-WS artifacts - service enpoint interfaces (SEIs) and services. Together
        they allow to make web service call. <br /><br />

        User may specify additional options during <span class="code">wsimport</span> execution.
        The most common options are:
    </p>
    <ul>
        <li><span class="code">-d &lt;directory&gt;&thinsp; </span>  - specifies output directory for generated files</li>
        <li><span class="code">-b &lt;path&gt;</span> - specifies path to JAXB custom binding files (one
            <span class="code">-b</span> option per one binding file)</li>
        <li><span class="code">-B &lt;jaxbOption&gt;</span> - options to pass to JAXB compiler </li>
        <li><span class="code">-keep</span> - keep generated sources</li>
        <li><span class="code">-p </span> specify the output package name (overrides namespace to package mapping
            and any package mapping defined in custom binding file)</li>
    </ul>

    <p>
        The corresponding set of Maven options is:
    </p>

    <ul>
        <li><span class="code">&lt;destDir&gt;</span></li>
        <li><span class="code">&lt;bindingFiles&gt;</span></li>
        <li><span class="code">&lt;xjcArgs&gt;</span></li>
        <li><span class="code">&lt;keep&gt;</span></li>
        <li><span class="code">&lt;packageName&gt;</span></li>
    </ul>

    <p>
        It is important to provide custom binding files for services that requires them. After <span class="code">wsimport</span>
        is invoked, two kinds of artifacts are created:
    </p>

    <ul>
        <li>JAXB value types (JAXB-annotated Java classes that represent data types used in schemas)</li>
        <li>JAX-WS artifacts: Services, Service Endpoint Interfaces and Services Endpoint Implementations (both latter referred to as SEI's)</li>
    </ul>

    <p>
        They will be used to develop a client. The first thing to do is to construct objects that will represent
        a web service request. For each web service call three objects must be constructed: message header,
        security header containing either credentials (during session creation) or security token (after the session
        is created) and a request body. <br /><br />

        Next, the Service object (whose class name matches the service name defined in WSDL file) is used to obtain
        a Service Endpoint Implementation object (whose class name matches port name defined in WSDL file).
        This object contains a public method that allows to make web service call. The name of this method
        is the same as operation name, defined in <span class="code">&lt;wsdl:operation&gt;</span> element in
        <span class="code">&lt;wsdl:binding&gt;</span> section of the WSDL file. <br /><br/>

        This method takes 3 parameters: <span class="code">MessageHeader</span> object wrapped in
        <span class="code">Holder&lt;MessageHeader&gt;</span>, <span class="code">Security</span> object
        wrapped in  <span class="code">Holder&lt;Security&gt;</span> and a request body (not wrapped).
        The <span class="code">Holder&lt;&gt;</span> mechanism allows the parameters to work as both input and output
        objects. During method invokation they are marshalled and inserted into message, and when the method returns
        they are obtained from the response message, unmarshalled into objects and placed in <span class="code">Holder</span>s.
        To get returned objects, use <span class="code">Holder</span> instance's <span class="code">value()</span> method. <br />
        This is a convenient way of obtaining session token from <span class="code">SessionCreateRQ</span> service's response.

        This example shows how to create a Sabre&reg; session and retrieve session token:

    </p>

    <!-- HTML generated using hilite.me --><div style="background: #111111; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #ffffff">MessageHeader</span> <span style="color: #ffffff">header</span> <span style="color: #ffffff">=</span> <span style="color: #ffffff">getSessionCreateRQMessageHeader();</span> <span style="color: #008800; font-style: italic; background-color: #0f140f">// create a valid object</span>
<span style="color: #ffffff">Security</span> <span style="color: #ffffff">security</span> <span style="color: #ffffff">=</span> <span style="color: #ffffff">getSecurityHeader();</span> <span style="color: #008800; font-style: italic; background-color: #0f140f">// create a valid object</span>
<span style="color: #ffffff">SessionCreateRQ</span> <span style="color: #ffffff">requestBody</span> <span style="color: #ffffff">=</span> <span style="color: #ffffff">getSessionCreateRQ();</span> <span style="color: #008800; font-style: italic; background-color: #0f140f">//create a valid object</span>

<span style="color: #ffffff">Holder&lt;MessageHeader&gt;</span> <span style="color: #ffffff">headerHolder</span> <span style="color: #ffffff">=</span> <span style="color: #fb660a; font-weight: bold">new</span> <span style="color: #ffffff">Holder&lt;&gt;(header);</span>
<span style="color: #ffffff">Holder&lt;Security&gt;</span> <span style="color: #ffffff">securityHolder</span> <span style="color: #ffffff">=</span> <span style="color: #fb660a; font-weight: bold">new</span> <span style="color: #ffffff">Holder&lt;&gt;(security);</span>

<span style="color: #ffffff">SessionCreatePortType</span> <span style="color: #ffffff">port</span> <span style="color: #ffffff">=</span> <span style="color: #fb660a; font-weight: bold">new</span> <span style="color: #ffffff">SessionCreateRQService().</span><span style="color: #ff0086; font-weight: bold">getSessionCreatePortType</span><span style="color: #ffffff">();</span>

<span style="color: #ffffff">SessionCreateRS</span> <span style="color: #ffffff">responseBody</span> <span style="color: #ffffff">=</span> <span style="color: #ffffff">port.</span><span style="color: #ff0086; font-weight: bold">sessionCreateRQ</span><span style="color: #ffffff">(headerHolder,</span> <span style="color: #ffffff">securityHolder,</span> <span style="color: #ffffff">getRequestBody());</span> <span style="color: #008800; font-style: italic; background-color: #0f140f">// actual web service request</span>

<span style="color: #008800; font-style: italic; background-color: #0f140f">// since now on, holders contain headers from response message</span>
<span style="color: #ffffff">String</span> <span style="color: #ffffff">sessionToken</span> <span style="color: #ffffff">=</span> <span style="color: #ffffff">securityHolder.</span><span style="color: #ff0086; font-weight: bold">value</span><span style="color: #ffffff">().</span><span style="color: #ff0086; font-weight: bold">getBinarySecurityToken</span><span style="color: #ffffff">();</span>
</pre></td></tr></table></div>

    <p>
        This pattern holds for every Sabre&reg; Web Service request with <span class="code">wsimport</span>:
        create header, wrap them into holders, build request object, pass them all to SEI's method, get response object
        as method's return value and access response's headers (if there's need to).
        <br /><br />
        Note one important thing - by default, port class will use the endpoint URL specified in WSDL file, from which
        it was created. However, this could be highly undesirable, especially during the development and testing phase,
        as this would be <span class="code">https://webservices.sabre.com/websvc</span> - it's a production endpoint and
        performing any operations on it may generate charges on customer's account and decrement real-time inventory.
        During development, one would probably use Sabre&reg; test system or even mocked service. To change endpoint URL
        used by your service's client, please do as following (or see one of classes in
        <span class="code">com.sabre.sws.tools.wsdl.wsimport.wrappers</span> package in
        <span class="code">toolkit-wsimport</span> <a href="sample_client_documentation.html">sample project</a>):
        <br /><br />
    </p>

    <p>
        SOAP Handlers <br/><br/>

        <span class="code">wsimport</span> provides easy-to-use handlers mechanism. It allows to manipulate the message
        content after it's created and before it's send (when handling requests) or to handle message after it is
        received (when handling responses). Using handler gives a developer access to whole message's content.
        Classes used in handlers reside in <span class="code">javax.xml.soap</span> package and implement
        <span class="code">org.w3c.dom</span> API, so it's possible to manipulate SOAP envelope elements this way. <br /><br />

        SOAP handlers must implement <span class="code">javax.xml.ws.handler.soap.SOAPHandler</span> interface.
        The most important method in terms of manipulating the message is <span class="code">public boolean handleMessage(MessageContext context)</span>.
        One should implement this method in order to do the necessary message handling. <br /><br />

        To add a handler to a web service call described in previous example, simply add the following lines before
        service call method invokation:

        <!-- HTML generated using hilite.me --><div style="background: #111111; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%">1
2
3</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #ffffff">List</span> <span style="color: #ffffff">&lt;SOAPHandler&gt;</span> <span style="color: #ffffff">handlers</span> <span style="color: #ffffff">=</span> <span style="color: #fb660a; font-weight: bold">new</span> <span style="color: #ffffff">ArrayList&lt;&gt;();</span>
<span style="color: #ffffff">handlers.</span><span style="color: #ff0086; font-weight: bold">add</span><span style="color: #ffffff">(</span><span style="color: #fb660a; font-weight: bold">new</span> <span style="color: #ffffff">YourCustomHandler());</span> <span style="color: #008800; font-style: italic; background-color: #0f140f">// assuming YourCustomHandler implements SOAPHandler</span>
<span style="color: #ffffff">((BindingProvider)port).</span><span style="color: #ff0086; font-weight: bold">getBinding</span><span style="color: #ffffff">().</span><span style="color: #ff0086; font-weight: bold">setHandlerChain</span><span style="color: #ffffff">(handlers);</span>
</pre></td></tr></table></div> <br />

    One can read more on handlers in wsimport on <a href="https://jax-ws.java.net/nonav/2.1.1/docs/handlers.html">JAX-WS docs</a>
    and in <a href="https://jax-ws.java.net/articles/handlers_introduction.html">article on JAX-WS site</a>
    </p>

    <p>
        All above concepts are implemented in <a href="sample_client_documentation.html">sample project</a>, in <span class="code">toolkit-wsimport</span> module.
    </p>

    <!-- Summary -->
    <a name="wsimport-known-issues-anchor"></a>
    <span class="bold"> Summary </span><br/>
    <p>
        Currently wsimport causes no troubles when used to consume Sabre API. It is a JAX-WS implementation,
        which is a widely used standard. It also uses JAXB data binding, which is portable, popular and well-documented.
    </p>

    </div>

    <!-- Apache CXF framework -->

    <a name="cxf-framework-anchor"></a>
    <span class="subheader">Apache CXF</span><br/><br/> <!-- Framework name -->
    <div class="intend-level-1">

        <!-- Overview -->
        <a name="cxf-overview-anchor"></a>
        <span class="bold"> Overview </span><br/>
        <p>

            Apache CXF is another framework designed strictly for the purpose of working with web services. It implements the JAX-WS
            specification.
            In general, it provides same functionality as Axis2, which means the ability to send, process and receive messages,
            both to and from services. Similarly, CXF allows user to develop both client and server side application.
            It uses <span class="italic">contract-first</span> approach, which means creation of service implementation code based on service definition
            (in form ow WSDL files and schema definition). What it means for Sabre API consumer, is that Java client
            code can be generated easily based on WSDL and XSD files, available on
            <a href="http://developer.sabre.com">Sabre&reg; Dev Studio</a>.
            <br />
            Client code will consist of classes similar to service stubs in Axis2, Services and PortTypes (which represent
            JAX-WS service and service endpoint implementation artifacts, respectively), allowing
            user to invoke services calls, and accompanying binding classes representing types defined in schemas.
            Developer's role is to construct an object representing request to be invoked, pass it to a method representing
            service call, and then to process the response.

        </p>

        <!-- Using Framework -->
        <a name="cxf-using-anchor"></a>
        <span class="bold"> Using </span><br/><br/>
        <p>
            To use CXF framework in a Java project, one can use either source or binary distribution.
            They are both available at <a href="http://cxf.apache.org/download.html">CXF's download site</a>.<br />
            It is also possible to use CXF via Maven dependency management system. It is actually the best way,
            as it requires the least configuration effort. Dependencies that need to be placed in POM in order to
            use Apache CXF are described <a href="http://cxf.apache.org/docs/using-cxf-with-maven.html">in project's documentation</a>. <br/><br />

            Generally, using CXF to develop Sabre API client application boils down to two separate things:
            generating all the necessery Java classes from service definition in WSDL file (using CXF code generation feature)
            and using CXF's classes in your client code to make web services call. <br />

            CXF's code generation feature may be used in one of three ways: <br />
        </p>

        <ul>
            <li>As a command line tool</li>
            <li>As Maven goal</li>
            <li>Via WSDL2Java API at runtime</li>
        </ul>

        <p>
            The documentation for command line tool can be obtained on
            <a href="http://cxf.apache.org/docs/wsdl-to-java.html"><span class="code">wsdl2java</span> tool reference site</a>,
            and maven plugin documentation is available in
            <a href="http://cxf.apache.org/docs/using-cxf-with-maven.html#UsingCXFwithmaven-MavenPlugin">
                maven plugin section of CXF docs
            </a>
            and <a href="http://cxf.apache.org/docs/maven-cxf-codegen-plugin-wsdl-to-java.html">CXF's codegen plugin site</a>.
        </p>


        <!-- Typical flow in particular framework -->
        <a name="cxf-typical-flow-anchor"></a>
        <span class="bold"> Typical flow </span><br/>
        <p>
            Using CXF to consume web services is generally no different than using Axis2 and invloves:
        </p>

        <!-- Typical flow list -->
        <ol>
            <li>Collecting all necessary files (WSDL, XML and XSD) for each service</li>
            <li>Generating services stubs code (JAX-WS artifacts), using one of the data binding frameworks (e.g. XMLBeans, JAXB)</li>
            <li>Creating client, which will use generated code</li>
            <li>Providing interceptors for messages</li>
            <li>Invoking services via adequate methods calls</li>
            <li>Receiving and handling the response</li>
        </ol>



        <!-- Details of client development -->
        <a name="cxf-developing-client-anchor"></a>
        <span class="bold"> Developing client in detail </span><br/>
        <p>
            Client development starts with collecting services definitions and schema definitions (WSDL and XSD) files.
            They are available for Sabre&reg; clients on web. Note, that code generation tool expect all the necessary schemas
            to be present in the same directory as WSDL file. So be sure to place there not only the service specific files,
            but also common schemas (they are needed to create SOAP envelope and message correctly).
            <br /><br />
            When required files are gathered, <span class="code">wsdl2java</span> tool can be used to generate client code.
            Check documentation mentioned before for details on how to use this tool.
            <br /><br />
            On this stage, developer must decide which data binding framework to use for client code generation. The recommended
            one is JAXB, as it is quite easy to use and elastic, yet powerful. The ADB and XMLBeans frameworks have disadvantages
            described in their sections. The proper use of JAXB data binding requires taking additional steps
            (creating custom binding files), as described in next section. However, this is not difficult thing to do.
            The structure of binding file and it's usage is desribed in <a href="#jaxb-execution-requirements-anchor">JAXB section of this document.</a>
            <br /><br />
            The next step is to create a client, which will utilize generated classes to access web services.
            This process requires a bit of knowledge about how the CXF framework works. This will be covered here briefly. To see
            a full working example, please refer to the <a href="sample_client_documentation.html">sample project</a>, provided by Sabre API Team
            (<span class="code">toolkit-cxf-jaxb</span> module).
            <br /><br />
            CXF generates two main data types (JAX-WS asrtifacts) for each service defined in WSDL file:
            <span class="code">&lt;ServiceName&gt;Service extends javax.xml.ws.Service</span> class and
            <span class="code">&lt;ServiceName&gt;PortType</span> interface.
            <br /><br />
            The first one provides two useful components:
        </p>
        <ul>
            <li>Default constructor - creates service class, based on information contained in WSDL file at the time
                of generating this class (assumes, that WSDL file is still available in the same location)</li>
            <li><span class="code">get_PortName_()</span> method - returns a class associated with specific
                port defined in service. This class maps each operation defined in the WSDL file to a corresponding method,
                whose invokation is equivalent to a web service call.</li>
        </ul>

        <p>
            The latter method takes 3 parameters: <span class="code">MessageHeader</span> object wrapped in <span class="code">Holder&lt;MessageHeader&gt;</span>,
            <span class="code">Security</span> object wrapped in <span class="code">Holder&lt;Security&gt;</span> and a request body (not wrapped).
            The <span class="code">Holder&lt;&gt;</span> mechanism
            (based on <span class="code">javax.xml.ws.Holder</span> class) allows
            the parameters to work as both input and output objects. During method invokation they are marshalled
            and inserted into message, and when the method returns they are obtained from the response message,
            unmarshaled into objects and placed in Holders. To get returned objects, use Holder instance's
            <span class="code">value()</span> method.

            So, based on <a href="sample_client_documentation.html">sample project</a>, the invokation of Sabre's OTA_AirAvailLLSRQ would look something like this:
            <br /><br />
            <!-- HTML generated using hilite.me --><div style="background: #111111; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%">1
2
3</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #ffffff">  OTAAirAvailService</span> <span style="color: #ffffff">service</span> <span style="color: #ffffff">=</span> <span style="color: #fb660a; font-weight: bold">new</span> <span style="color: #ffffff">OTAAirAvailService();</span>
<span style="color: #ffffff">  OTAAirAvailPortType</span> <span style="color: #ffffff">port</span> <span style="color: #ffffff">=</span> <span style="color: #ffffff">service.</span><span style="color: #ff0086; font-weight: bold">getOTAAirAvailPortType</span><span style="color: #ffffff">();</span>
<span style="color: #ffffff">  OTAAirAvailRS</span> <span style="color: #ffffff">serviceResponse</span> <span style="color: #ffffff">=</span> <span style="color: #ffffff">port.</span><span style="color: #ff0086; font-weight: bold">otaAirAvail</span><span style="color: #ffffff">(...);</span> <span style="color: #008800; font-style: italic; background-color: #0f140f">// set correct arguments </span>
</pre></td></tr></table></div>

        <br />

        After implementing logic to create requests and handle respones, one must define interceptors for services. Interceptors
        are necessary to get access to full SOAP envelope. Invoking methods on port class allows only to see response body,
        which is not enough information to successfully consume Sabre API. Typically, one would like to
        access the data in SOAP envelope and header. Interceptors allow exactly to do that.
        <br/>
        In the <a href="sample_client_documentation.html">sample project</a>, interceptor classes are derived from
        <span class="code">org.apache.cxf.binding.soap.interceptor.AbstractSoapInterceptor</span> class, which
        provides means of accessing full SOAP message via <span class="code">handleMessage(SoapMessage message)</span> method.
        It is possible to get full information from SOAP message as stream, however, this will leave the message empty.
        To avoid error on further processing, data must be copied and placed back into the message
        (see <span class="code">LLSErrorInterceptor</span> class from
        <span class="code">com.sabre.sws.tools.wsdl.cxf.jaxb.interceptors</span> package in
        <span class="code">toolkit-cxf-jaxb</span> module in <a href="sample_client_documentation.html">sample project</a>).
        Interceptor must be placed in a correct phase, so that the expected data is present in the message as it is being processed.
        For the detailed information about phases and interceptor chains, please refer to the
        <a href="http://cxf.apache.org/docs/interceptors.html"> CXF's documentation</a>.
        <br /><br />
        Note one important thing - by default, port class will use the endpoint URL specified in WSDL file, from which
        it was created. However, this could be highly undesirable, especially during the development and testing phase,
        as this would be <span class="code">https://webservices.sabre.com/websvc</span> - it's a production endpoint and
        performing any operations on it may generate charges on customer's account and decrement real-time inventory.
        During development, one would probably use Sabre&reg; test system or even mocked service. To change endpoint URL
        used by your service's client, please do as following (or see one of classes in
        <span class="code">com.sabre.sws.tools.wsdl.cxf.jaxb.wrappers</span> package in <span class="code">toolkit-cxf-jaxb</span>
        module of a <a href="sample_client_documentation.html">sample project</a>):
        <br /><br />

        <!-- HTML generated using hilite.me --><div style="background: #111111; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="color: yellow;margin: 0; line-height: 125%">1
2
3
4
5</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #ffffff">  String</span> <span style="color: #ffffff">endpointURL</span> <span style="color: #ffffff">=</span> <span style="color: #0086d2">&quot;http://some.test.url/svc&quot;</span><span style="color: #ffffff">;</span>
<span style="color: #ffffff">  OTAAirAvailService</span> <span style="color: #ffffff">service</span> <span style="color: #ffffff">=</span> <span style="color: #fb660a; font-weight: bold">new</span> <span style="color: #ffffff">OTAAirAvailService();</span>
<span style="color: #ffffff">  OTAAirAvailPortType</span> <span style="color: #ffffff">port</span> <span style="color: #ffffff">=</span> <span style="color: #ffffff">service.</span><span style="color: #ff0086; font-weight: bold">getOTAAirAvailPortType</span><span style="color: #ffffff">();</span>
<span style="color: #ffffff">  BindingProvider</span> <span style="color: #ffffff">bindingProvider</span> <span style="color: #ffffff">=</span> <span style="color: #ffffff">(BindingProvider)</span> <span style="color: #ffffff">port;</span>
<span style="color: #ffffff">  bindingProvider.</span><span style="color: #ff0086; font-weight: bold">getRequestContext</span><span style="color: #ffffff">().</span><span style="color: #ff0086; font-weight: bold">put</span><span style="color: #ffffff">(BindingProvider.</span><span style="color: #ff0086; font-weight: bold">ENDPOINT_ADDRESS_PROPERTY</span><span style="color: #ffffff">,</span> <span style="color: #ffffff">endpointURL);</span>
</pre></td></tr></table></div>


        <br /><br />
        After all these steps are taken, one has to create a valid request object and pass it to port's method corresponding
        to the desired service, along with proper header holders (as in the <a href="sample_client_documentation.html">sample project</a>).
        The method will return response object, which may be further processed to extract required information from it.
        </p>

        <!-- Summary -->
        <a name="cxf-known-issues-anchor"></a>
        <span class="bold"> Summary </span><br/>

        <br />
    </div>


    <!-- Apache Axis2 framework -->

    <a name="axis2-framework-anchor"></a>
    <span class="subheader"> Apache Axis2 </span><br/><br/> <!-- Framework name -->
    <div class="intend-level-1">

        <!-- Overview -->
        <a name="axis2-overview-anchor"></a>
        <span class="bold"> Overview </span><br/>
        <p>

            Apache Axis2 is a Java framework for working with WebServices, SOAP and WSDL. It provides means to create, send, receive and handle
            SOAP messages to and from web services. <br />
            Axis2 Engine has two main functionalities:
        </p>
            <ul>
                <li>Providing services as a web services server</li>
                <li>Consuimng services from server as a web services client</li>
            </ul>
        <p>
            The use of both is similar - one should provide Axis2 with web services description in form of WSDL files,
            and it will produce corresponding java code. When generating clients, the framework will produce service stubs.
            Generated stubs will contain two major components:
        </p>
            <ul>
                <li>Static inner classes for each complex type defined in corresponding XSD file </li>
                <li>Methods to invoke web services calls (one method per each binding defined in WSDL file) </li>
            </ul>
        <p>
            When generating services stubs, Axis2 will take a WSDL file (with all related XSD files) and respond with appropriate
            structure of directories and classes. The next step is to fill generated classes' methods with business-logic code to provide
            desired functionality for services. Among generated files there will be a Ant <span class="code" >build.xml</span> file. When invoked on that
            file, Ant will compile all sources and pack them into a WAR archive, ready to deploy into a web server, such as Tomcat.
        </p>

        <!-- Using Framework -->
        <a name="axis2-using-anchor"></a>
        <span class="bold"> Using </span><br/>
        <p>
            Axis2 may be used either as stand-alone command line tool or as a Maven plugin. When using Axis2 from command line,
            user must specify <span class="code">AXIS2_HOME</span> home variable, pointing to the location of Axis2 directory.
            Appending <span class="code">$AXIS2_HOME/bin</span> (or <span class="code">%AXIS2_HOME%\bin</span> under Windows)
            to <span class="code">PATH</span> system variable will allow to run Axis2-related scripts easily. <br /><br />
            Using Axis2 as Maven dependency will be no surprise for Maven users. For information about versioning and
            dependencies, see <a href="http://mvnrepository.com/artifact/org.apache.axis2">Maven repository site</a>.
            To see a working example with full set of dependencies, check <a href="sample_client_documentation.html">sample project</a>, provided by Sabre API Team.
        </p>

        <!-- Typical flow in particular framework -->
        <a name="axis2-typical-flow-anchor"></a>
        <span class="bold"> Typical flow </span><br/>
        <p>
            Consuming web services with Axis2 constists of the following steps:
        </p>
            <!-- Typical flow list -->
            <ol>
                <li>Collecting all necessary files (WSDL, XML and XSD) for each service</li>
                <li>Generating services stubs code, using one of the data binding frameworks (e.g. ADB, XMLBeans, JiBX)</li>
                <li>Creating client, which will use services stubs</li>
                <li>Providing handlers for messages (this is described below)</li>
                <li>Invoking services via adequate methods calls</li>
                <li>Receiving and handling the response</li>
            </ol>

        <!-- Details of client development -->
        <a name="axis2-developing-client-anchor"></a>
        <span class="bold"> Developing client in detail </span><br/>
        <p>
            Client generation is accomplished through invoking <span class="code">wsdl2java</span> tool. <br />
        </p>
            <span class="code">wsdl2java</span> may be accessed in various ways:
            <ul>
                <li>As stand-alone command line tool</li>
                <li>As Ant task</li>
                <li>As maven plugin</li>
            </ul>
        <p>
            Usage of all of the above is similar. It requires specifying location of the WSDL and XML Schema files,
            output location for the generated sources and package name for generated classes. Unless told differently,
            ADB (the default data binding for Axis2) generates one big stub class per one web service definition
            (or, alternatively, one stub java class per one WSDL file). Parameters are passed as command line options
            when running from command line. In case of invoking via Ant or Maven tool they are specified in adequate
            XML file (build.xml or pom.xml). <br /><br />

            Generating clients via command line tool is done by executing the following script: <br /><br/>

            <span class="code">
            $AXIS2_HOME/bin/wsdl2java.sh -uri &lt;path_to_.wsdl_file&gt; -p &lt;output_package_name&gt; -d &lt;data_binding_framework&gt; -o &lt;output_directory&gt; <br /><br />
            </span>

            As one could expect, executing the above generates client's side services stubs for services described in the WSDL file,
            path to which is provided after <span class="code">-uri</span> option. Classes are generated into specified
            output directory (<span class="code">-o</span> option) under specified package (<span class="code">-p</span>).
            Proper data binding framework is used (<span class="code">-d</span>).
            The command line tool is documented in detail on <a href="http://axis.apache.org/axis2/java/core/docs/reference.html">Axis2's reference</a>.
            <br /><br />

            For the detailed parameters specification, see:
        </p>
            <ul>
                <li> <a href="http://axis.apache.org/axis2/java/core/tools/CodegenToolReference.html">Codegen tool reference site</a> for command line and Ant </li>
                <li> <a href="http://axis.apache.org/axis2/java/core/tools/maven-plugins/maven-wsdl2code-plugin.html"><span class="code">wsdl2code</span> tool documentation</a> for Maven plugin </li>
            </ul>


        <p>Handlers</p>

        <p>
            Handlers are classes that extend the <span class="code" >org.apache.axis2.handlers.AbstractHandler</span> class.
            A handler must extends that abstract class and implement
            <span class="code">public&nbsp;Handler.InvocationResponse&nbsp;invoke(MessageContext&nbsp;msgContext)&nbsp;throws&nbsp;AxisFault</span>
            method. Per each message in specified scope, this method will be invoked with the corresponding <span class="code">MessageContext</span>
            object as a parameter. <br />
            Specifying a proper set of handlers is generally advised. The handlers will form the first line of error detection and
            processing system. Error handlers should check if the response from the server contains any
            <span class="code">&lt;Fault&gt;</span> or <span class="code">&lt;Error&gt;</span> elements and if so, they should prevent
            it from being processed. Any additional message check can be performed. After ensuring the message is valid,
            the normal content processing flow may be continued.
            <br /><br />
            There is a situation when specifying a handler is mandatory. It is when a message going in or out
            contains a <span class="code">mustUnderstand="1"</span> attribute value. Each such message must be handled in the proper way,
            or <span class="code">org.apache.axis2.AxisFault</span> will be thrown. To avoid this and ensure correct
            <span class="code">mustUnderstand="1"</span> handling, the following step must be taken:
        </p>

        <ul>
            <li>
                The <span class="code">setProcessed()</span> method must be invoked on each of the <span class="code">SOAPHeaderBlock</span>
                members of the <span class="code">SOAPHeader</span> element of the current context.
            </li>
        </ul>
        <p>
            The example flow may look something like this:
        </p>
        <!-- HTML generated using hilite.me --><div style="background: #111111; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%">1
2
3
4
5
6
7
8</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #ffffff">SOAPHeader</span> <span style="color: #ffffff">header</span> <span style="color: #ffffff">=</span> <span style="color: #ffffff">msgContext.</span><span style="color: #ff0086; font-weight: bold">getEnvelope</span><span style="color: #ffffff">().</span><span style="color: #ff0086; font-weight: bold">getHeader</span><span style="color: #ffffff">();</span>
<span style="color: #ffffff">Iterator</span> <span style="color: #ffffff">headerBlocksIterator</span> <span style="color: #ffffff">=</span> <span style="color: #ffffff">header.</span><span style="color: #ff0086; font-weight: bold">getHeadersToProcess</span><span style="color: #ffffff">(</span><span style="color: #fb660a; font-weight: bold">null</span><span style="color: #ffffff">);</span>

<span style="color: #fb660a; font-weight: bold">while</span><span style="color: #ffffff">(</span> <span style="color: #ffffff">headerBlocksIterator.</span><span style="color: #ff0086; font-weight: bold">hasNext</span><span style="color: #ffffff">()</span> <span style="color: #ffffff">)</span> <span style="color: #ffffff">{</span>
<span style="color: #ffffff">  SOAPHeaderBlock</span> <span style="color: #ffffff">headerBlock</span> <span style="color: #ffffff">=</span> <span style="color: #ffffff">(SOAPHeaderBlock)</span> <span style="color: #ffffff">headerBlocksIterator.</span><span style="color: #ff0086; font-weight: bold">next</span><span style="color: #ffffff">();</span>
<span style="color: #ffffff">  </span><span style="color: #008800; font-style: italic; background-color: #0f140f">// process header block</span>
<span style="color: #ffffff">  headerBlock.</span><span style="color: #ff0086; font-weight: bold">setProcessed</span><span style="color: #ffffff">();</span>
<span style="color: #ffffff">}</span>
</pre></td></tr></table></div>

        <br />

        <!-- Summary -->
        <!--<a name="axis2-known-issues-anchor"></a>
        <span class="bold"> Summary </span><br/><br/>
        <p class="intend-level-2">

        </p>-->

    </div>


    <!-- Spring Web Services -->

    <a name="spring-ws-framework-anchor"></a>
    <span class="subheader">Spring Web Services</span><br/><br/> <!-- Framework name -->
    <div class="intend-level-1">

    <!-- Overview -->
    <a name="springws-overview-anchor"></a>
    <span class="bold"> Overview </span><br/>
    <p>
        Spring Web Services (Spring WS) is part of the Spring Framework responsible for working with web services.
        It benefits from that fact in many ways, simplifying and automating many things. However, Spring WS takes a bit
        different approach to building web services than previously described frameworks - it works on a lower level,
        exposing to user things, that other frameworks do behind the scenes. It gives more control over the process to the developer,
        but requires more effort.
        <br /><br />
        Spring WS also uses <span class="italic">contract-first </span> approach, so user is encouraged to develop client code
        based on existing service definition. Main difference is, that Spring WS handles marshalling and sending of a single object
        well, but requires more effort to compose the message consisting of multiple elements. This will be covered in following
        section, and the full working implementation may be seen in <a href="sample_client_documentation.html">sample project</a>, at <span class="code">toolkit-spring-ws</span>
        module.
    </p>

    <!-- Using Framework -->
    <a name="springws-using-anchor"></a>
    <span class="bold"> Using </span><br/>
    <p>
        Spring Web Services does not provide it's own code generation tool, so using it is just a matter of
        placing Spring WS jars in your classpath. This is easiest done via dependency management system, like Maven or Gradle.
        This also means, that user has to take care of compiling schemas to java classes him or herself. Since it is assumed
        that system like Maven is being used, the easiest way is to utilize one of binding plugins. Two examples of JAXB Maven
        plugins are listed in previous section.
    </p>

    <!-- Typical flow in particular framework -->
    <a name="springws-typical-flow-anchor"></a>
    <span class="bold"> Typical flow </span><br/>
    <ol>
        <li>Collecting all necessary schema definition files (WSDL files are not required)</li>
        <li>Compiling schemas into Java code using external data binding, like JAXB (e.g. in form of a plugin)</li>
        <li>Creating client, which will use generated code</li>
        <li>Configuring Spring to take advantage of it's IoC capabilities (optional)</li>
        <li>Providing interceptors and callbacks for messages</li>
        <li>Invoking services via adequate methods calls</li>
        <li>Receiving and handling the response</li>
    </ol>

    <!-- Details of client development -->
    <a name="springws-developing-client-anchor"></a>
    <span class="bold"> Developing client in detail </span><br/>
    <p>
        When using Spring WS, only schema definitions are required, for developer takes care of creating the message.
        In fact, the minimal set of schemas required to consume Sabre API consists of request and response
        definitions for each service and schemas of security and message headers to build the envelope.
        <br />
        These files should be then compiled to Java classes. <a href="sample_client_documentation.html">sample project</a> uses JAXB2 Maven plugin to achieve this.
        Spring WS provides one main class to send and receive web services message: <span class="code">WebServiceTemplate</span>,
        which resides in <span class="code">org.springframework.ws.client.core</span> package.
        This class contains many methods to invoke web services calls. Two most important of them are
        <span class="code">sendSourceAndReceiveToResult(...)</span> and <span class="code">marshallSendAndReceive(...)</span>.
        The former takes two parameters: <span class="code">javax.xml.transform.Source</span>, from which it reads
        the request to send, and <span class="code">javax.xml.transform.Result</span>, to which it writes the response.
        The latter allows working with POJO's and hides the details of marshalling and unmarshalling from the developer.
        It returns <span class="code">Object</span> type and takes one object as a parameter. Before calling this
        method, developer must configure the <span class="code">WebServiceTemplate</span> object by setting
        marshaller and unmarshaller and specifying web service's URI. URI may be set during constructing of an object
        through the constructor argument or set anytime before web service call via <span class="code">WebServiceTemplate</span>'s
        <span class="code">setDefaultUri(String uri)</span> method. The easiest way of providing marshaller and
        unmarshaller is to use Spring OXM's <span class="code">org.springframework.oxm.jaxb.Jaxb2Marshaller</span> class'
        object. It implements both <span class="code">Marshaller</span> and <span class="code">Unmarshaller</span>
        interfaces and is capable of marshalling and unmarshalling objects of classes that are generated via JAXB
        (and therefore annotated with proper JAX-WS annotations). <span class="code">Jaxb2Marshaller</span>
        must be supplied with a <span class="code">contextPath</span> - a <span class="code">String</span> containing
        colon-separated packages names with classes to marshall. <br/><br/>

        After such configuration one can call <span class="code">marshallSendAndReceive(...)</span>. It then will
        marshall the parameter object, put it into the message, send the message to the URI specified, obtain
        the response, unmarshall it and return resulting object as method return value. <br/><br/>

        It is also possible to use Spring's convenience class
        <span class="code">org.springframework.ws.client.core.support.WebServiceGatewaySupport</span>, which encapsulates
        <span class="code">WebServiceTemplate</span> and exposes convenient bean properties to enable easy configuration.
        However, this is not mandatory. <br /><br />

        To get comprehensive information on Spring WS client development, please check <a href="sample_client_documentation.html">sample project</a>
        (<span class="code">toolkit-spring-ws</span> module) or some of the following:
    </p>

    <ul>
        <li>
            <a href="http://docs.spring.io/spring-ws/docs/2.2.0.RELEASE/reference/htmlsingle/#client">
                Spring WS reference on client development
            </a>
        </li>
        <li><a href="http://spring.io/guides/gs/consuming-web-service/">Spring WS guide</a></li>
        <li><a href="http://docs.spring.io/spring-ws/docs/2.2.0.RELEASE/api/org/springframework/ws/client/core/WebServiceTemplate.html">
            <span class="code">WebServiceTemplate</span> JavaDoc
        </a></li>
        <li><a href="http://docs.spring.io/spring-ws/docs/2.2.0.RELEASE/api/org/springframework/ws/client/core/support/WebServiceGatewaySupport.html">
            <span class="code">WebServiceGatewaySupport</span> JavaDoc
        </a></li>
        <li><a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/oxm/jaxb/Jaxb2Marshaller.html">
            <span class="code">Jaxb2Marshaller</span> JavaDoc
        </a></li>
    </ul>

    <p>
        Callbacks <br/><br/>

        Callbacks mechanism allows developer to manipulate the message content after it was created, but before it is
        send. Send methods described above have overloaded versions that take one Callback
        parameter. Since Spring WS leaves construction of a message to the developer, it is a good point to
        add all necessary headers into SOAP message. Sabre API require two custom headers:
        <span class="code">eb:MessageHeader</span> and <span class="code">wsse:Security</span>.
        They can be easily inserted in SOAP Envelope using callback. Callback must implement <span class="code">
            org.springframework.ws.client.core.WebServiceMessageCallback</span> interface and thus implement
        <span class="code">void doWithMessage(WebServiceMessage webServiceMessage)</span> method.
        The snippet below shows how to use this to compose correct message to work with Sabre API:
    </p>

    <!-- HTML generated using hilite.me --><div style="background: #111111; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #fb660a; font-weight: bold">public</span> <span style="color: #fb660a; font-weight: bold">class</span> <span style="color: #ffffff">HeaderComposingCallback</span> <span style="color: #fb660a; font-weight: bold">implements</span> <span style="color: #ffffff">WebServiceMessageCallback</span> <span style="color: #ffffff">{</span>
<span style="color: #ffffff"> @Override</span>
<span style="color: #ffffff"> </span><span style="color: #fb660a; font-weight: bold">public</span> <span style="color: #cdcaa9; font-weight: bold">void</span> <span style="color: #ffffff">doWithMessage(WebServiceMessage</span> <span style="color: #ffffff">webServiceMessage)</span> <span style="color: #fb660a; font-weight: bold">throws</span> <span style="color: #ffffff">IOException,</span> <span style="color: #ffffff">TransformerException</span> <span style="color: #ffffff">{</span>
<span style="color: #ffffff">   MessageHeader</span> <span style="color: #ffffff">header</span> <span style="color: #ffffff">=</span> <span style="color: #ffffff">...</span> <span style="color: #008800; font-style: italic; background-color: #0f140f">// get MessageHeader object</span>
<span style="color: #ffffff">   Security</span> <span style="color: #ffffff">security</span> <span style="color: #ffffff">=</span> <span style="color: #ffffff">...</span> <span style="color: #008800; font-style: italic; background-color: #0f140f">// get Security object</span>

<span style="color: #ffffff">   StringBuilder</span> <span style="color: #ffffff">builder</span> <span style="color: #ffffff">=</span> <span style="color: #fb660a; font-weight: bold">new</span> <span style="color: #ffffff">StringBuilder();</span>
<span style="color: #ffffff">   builder.</span><span style="color: #ff0086; font-weight: bold">append</span><span style="color: #ffffff">(header.</span><span style="color: #ff0086; font-weight: bold">getClass</span><span style="color: #ffffff">().</span><span style="color: #ff0086; font-weight: bold">getPackage</span><span style="color: #ffffff">().</span><span style="color: #ff0086; font-weight: bold">getName</span><span style="color: #ffffff">()).</span><span style="color: #ff0086; font-weight: bold">append</span><span style="color: #ffffff">(</span><span style="color: #0086d2">&quot;:&quot;</span><span style="color: #ffffff">);</span>
<span style="color: #ffffff">   builder.</span><span style="color: #ff0086; font-weight: bold">append</span><span style="color: #ffffff">(security.</span><span style="color: #ff0086; font-weight: bold">getClass</span><span style="color: #ffffff">().</span><span style="color: #ff0086; font-weight: bold">getPackage</span><span style="color: #ffffff">().</span><span style="color: #ff0086; font-weight: bold">getName</span><span style="color: #ffffff">());</span>
<span style="color: #ffffff">   Jaxb2Marshaller</span> <span style="color: #ffffff">marshaller</span> <span style="color: #ffffff">=</span> <span style="color: #fb660a; font-weight: bold">new</span> <span style="color: #ffffff">Jaxb2Marshaller();</span>
<span style="color: #ffffff">   marshaller.</span><span style="color: #ff0086; font-weight: bold">setContextPath</span><span style="color: #ffffff">(builder.</span><span style="color: #ff0086; font-weight: bold">toString</span><span style="color: #ffffff">());</span>

<span style="color: #ffffff">   SoapHeader</span> <span style="color: #ffffff">soapHeader</span> <span style="color: #ffffff">=</span> <span style="color: #ffffff">((SoapMessage)webServiceMessage).</span><span style="color: #ff0086; font-weight: bold">getSoapHeader</span><span style="color: #ffffff">();</span>
<span style="color: #ffffff">   marshaller.</span><span style="color: #ff0086; font-weight: bold">marshal</span><span style="color: #ffffff">(header,</span> <span style="color: #ffffff">soapHeader.</span><span style="color: #ff0086; font-weight: bold">getResult</span><span style="color: #ffffff">());</span>
<span style="color: #ffffff">   marshaller.</span><span style="color: #ff0086; font-weight: bold">marshal</span><span style="color: #ffffff">(security,</span> <span style="color: #ffffff">soapHeader.</span><span style="color: #ff0086; font-weight: bold">getResult</span><span style="color: #ffffff">());</span>
<span style="color: #ffffff"> }</span>
<span style="color: #ffffff">}</span>
</pre></td></tr></table></div>


    <p>
        The <a href="sample_client_documentation.html">sample project</a> uses this approach to create SOAP envelope and invoke Sabre API.
    </p>

    <p>
        Interceptors
    </p>

    <p>
        Spring Web Services provides also the interceptors mechanism. Using interceptors, one may gain access
        to <span class="code">MessageContext</span> object, which contains information about request and
        response messages, message exchange properties, endpoint and other useful data. As the interceptor
        allows to handle response message, it is a good mean of obtaining header information from it.
        In <a href="sample_client_documentation.html">sample project</a> this capability is utilized to retrieve session token from SessionCreateRQ
        service's response. <br/><br />
        Interceptor must implement <span class="code">org.springframework.ws.client.support.interceptor.ClientInterceptor</span>
        interface with four methods:
    </p>
    <ul>
        <li><span class="code">public boolean handleRequest(MessageContext messageContext)</span> </li>
        <li><span class="code">public boolean handleResponse(MessageContext messageContext)</span></li>
        <li><span class="code">public boolean handleFault(MessageContext messageContext)</span></li>
        <li><span class="code">public void afterCompletion(MessageContext messageContext, Exception e)</span></li>
    </ul>

    <p>
        The <span class="code">handleResponse</span> method may be used to retrieve token from message.
        It can be done by retrieving response from <span class="code">MessageContext</span>, then
        getting <span class="code">Security</span> header from it, unmarhaling it into object and
        finally getting session token from it with getter method. The snippet below shows the outline of
        code that need to be placed in <span class="code">handleResponse(MessageContext messageContext)</span> method:
    </p>

    <!-- HTML generated using hilite.me --><div style="background: #111111; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%">1
2
3
4
5
6
7
8
9</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #ffffff"> SoapMessage</span> <span style="color: #ffffff">message</span> <span style="color: #ffffff">=</span> <span style="color: #ffffff">(SoapMessage)</span> <span style="color: #ffffff">messageContext.</span><span style="color: #ff0086; font-weight: bold">getResponse</span><span style="color: #ffffff">();</span>
<span style="color: #ffffff"> Source</span> <span style="color: #ffffff">securitySource</span> <span style="color: #ffffff">=</span> <span style="color: #ffffff">message.</span><span style="color: #ff0086; font-weight: bold">getSoapHeader</span><span style="color: #ffffff">().</span><span style="color: #ff0086; font-weight: bold">examineHeaderElements</span><span style="color: #ffffff">(securityQName).</span><span style="color: #ff0086; font-weight: bold">next</span><span style="color: #ffffff">().</span><span style="color: #ff0086; font-weight: bold">getSource</span><span style="color: #ffffff">();</span>
<span style="color: #ffffff"> Source</span> <span style="color: #ffffff">headerSource</span> <span style="color: #ffffff">=</span> <span style="color: #ffffff">message.</span><span style="color: #ff0086; font-weight: bold">getSoapHeader</span><span style="color: #ffffff">().</span><span style="color: #ff0086; font-weight: bold">examineHeaderElements</span><span style="color: #ffffff">(headerQName).</span><span style="color: #ff0086; font-weight: bold">next</span><span style="color: #ffffff">().</span><span style="color: #ff0086; font-weight: bold">getSource</span><span style="color: #ffffff">();</span>
<span style="color: #ffffff"> Jaxb2Marshaller</span> <span style="color: #ffffff">=</span> <span style="color: #ffffff">...</span> <span style="color: #008800; font-style: italic; background-color: #0f140f">// create marshaller as in example above</span>
<span style="color: #ffffff"> Security</span> <span style="color: #ffffff">security</span> <span style="color: #ffffff">=</span> <span style="color: #ffffff">(Security)</span> <span style="color: #ffffff">marshaller.</span><span style="color: #ff0086; font-weight: bold">unmarshal</span><span style="color: #ffffff">(securitySource);</span>
<span style="color: #ffffff"> MessageHeader</span> <span style="color: #ffffff">header</span> <span style="color: #ffffff">=</span> <span style="color: #ffffff">(MessageHeader)</span> <span style="color: #ffffff">marshaller.</span><span style="color: #ff0086; font-weight: bold">unmarshal</span><span style="color: #ffffff">(headerSource);</span>

<span style="color: #ffffff"> String</span> <span style="color: #ffffff">token</span> <span style="color: #ffffff">=</span> <span style="color: #ffffff">security.</span><span style="color: #ff0086; font-weight: bold">getBinarySecurityToken</span><span style="color: #ffffff">();</span>
<span style="color: #ffffff"> String</span> <span style="color: #ffffff">conversationId</span> <span style="color: #ffffff">=</span> <span style="color: #ffffff">header.</span><span style="color: #ff0086; font-weight: bold">getConversationId</span><span style="color: #ffffff">();</span>
</pre></td></tr></table></div>


    <p>
        To see a full working example of interceptor use, refer to <a href="sample_client_documentation.html">sample project</a>, <span class="code">toolkit-spring-ws</span>
        module.
    </p>

    <!-- Summary -->
    <a name="springws-known-issues-anchor"></a>
    <span class="bold"> Summary </span><br/>
    <p>
        When using Spring beans configuration, one should make sure that all underlying resources
        are adjusted to it. This concerns mostly <span class="code">Jaxb2Marshaller</span> bean.
        When a bean of that class is configured, it will be injected into <span class="code">WebServiceTemplate</span>
        objects. In that case the marshaller bean must contain information about all used classes and packages.
        It means that all names and identifiers used in JAXB annotations have to be unique. To achieve that,
        code generation tool should be executed with care and may require extensive configuration
        to avoid names duplication (as Sabre API schemas share many common data structures in every service).
    </p>

    </div>



</body>