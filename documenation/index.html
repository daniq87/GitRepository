<!DOCTYPE html>
<html>

<head>

	<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">

    <link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>

<span class="header"> 1.	JAVA </span> <br /><br />
<span class="subheader"> 1.1.	Apache Axis2 </span> <br /><br />

<p>
    Apache Axis2 is a Java framework for working with WebServices, SOAP and WSDL. It provides means to create, send, receive and handle
    SOAP messages to and from web services. <br />
    Axis2 Engine has two main functionalities:
    <ul>
        <li>Providing services as a web services server</li>
        <li>Consuimng services from server as a web services client</li>
    </ul>

    The use of both is similar - one should provide Axis2 with web services description in form of WSDL files,
    and it will produce corresponding java code. When generating clients, the framework will produce service stubs.
    Generated stubs will contain two major components:

    <ul>
        <li>Static inner classes for each complex type defined in corresponding XSD file </li>
        <li>Methods to invoke web services calls (one method per each binding defined in WSDL file) </li>
    </ul>

    When generating services stubs, Axis2 will take a WSDL file (with all related XSD files) and respond with appropriate
    structure of directories and classes. The next step is to fill generated classes' methods with business-logic code to provide
    desired functionality for services. Among generated files there will be a Ant <span class="code" >build.xml</span> file. When invoked on that
    file, Ant will compile all sources and pack them into a WAR archive, ready to deploy into a web server, such as Tomcat.

</p>

<span class="bold">Using Axis2</span>

<p>
    Axis2 may be used either as stand-alone command line tool or as a Maven plugin. When using Axis2 from command line,
    user must specify <span class="code">AXIS2_HOME</span> home variable, pointing to the location of Axis2 directory.
    Appending <span class="code">$AXIS2_HOME/bin</span> (or <span class="code">%AXIS2_HOME%\bin</span> under Windows)
    to <span class="code">PATH</span> system variable will allow to run Axis2-related scripts easily. <br /><br />
    Using Axis2 as Maven dependency will be no surprise for Maven users. For information about versioning and
    dependencies, see <a href="http://mvnrepository.com/artifact/org.apache.axis2">Maven repository site</a>.
    To see a working example with full set of dependencies, check !!!sample project, provided by Sabre Web Services Team.
</p>

<span class="section">Typical Axis2 flow (client side)</span>

<p>
    Consuming web services with Axis2 contains of the following steps:

    <ol>
        <li>Collecting all necessary files (WSDL, XML and XSD) for each service</li>
        <li>Generating services stubs code, using one of the data binding frameworks (e.g. ADB, XMLBeans, JiBX)</li>
        <li>Creating client, which will use services stubs</li>
        <li>Providing handlers for messages (this is described below)</li>
        <li>Invoking services via adequate methods calls</li>
        <li>Receiving and handling the response</li>
    </ol>
</p>

<p>
    Client generation is accomplished through invoking <span class="code">wsdl2java</span> tool. <br /><br />

    <span class="code">wsdl2java</span> may be accessed in various ways:
<ul>
    <li>As stand-alone command line tool</li>
    <li>As Ant task</li>
    <li>As maven plugin</li>
</ul>

<p> Usage of all of the above is similar. It requires specifying location of the WSDL and XML Schema files, output location for
    the generated sources and package name for generated classes. Unless told differently, ADB generates one big stub class
    per one web service definition (or, alternatively, one stub java class per one WSDL file). Parameters are passed as
    command line options when running from command line. In case of invoking via Ant or Maven tool they are specified in adequate
    XML file (build.xml or pom.xml). <br /><br />

    Generating clients via command line tool is done by executing the following script: <br /><br/>

    <span class="code">
        $AXIS2_HOME/bin/wsdl2java.sh -uri &lt;path_to_.wsdl_file&gt; -p &lt;output_package_name&gt; -d &lt;data_binding_framework&gt; -o &lt;output_directory&gt; <br /><br />
    </span>
    As one could expect, executing the above generates client's side services stubs for services described in the WSDL file,
    path to which is provided after <span class="code">-uri</span> option. Classes are generated into specified
    output directory (<span class="code">-o</span> option) under specified package (<span class="code">-p</span>).
    Proper data binding framework is used (<span class="code">-d</span>).
    The command line tool is documented in detail <a href="http://axis.apache.org/axis2/java/core/docs/reference.html">HERE</a>.
<br /><br />

For the detailed parameters specification, see: </p>

<ul>
    <li> <a href="http://axis.apache.org/axis2/java/core/tools/CodegenToolReference.html">This</a> for command line and Ant </li>
    <li> <a href="http://axis.apache.org/axis2/java/core/tools/maven-plugins/maven-wsdl2code-plugin.html">This</a> for Maven plugin </li>
</ul>

</p> <br />


<p>Handlers</p>

<p>
    Handlers are classes that extend the <span class="code" >org.apache.axis2.handlers.AbstractHandler</span> class.
    A handler must extends that abstract class and implement
    <span class="code">public&nbsp;Handler.InvocationResponse&nbsp;invoke(MessageContext&nbsp;msgContext)&nbsp;throws&nbsp;AxisFault</span>
    method. Per each message in specified scope, this method will be invoked with the corresponding <span class="code">MessageContext</span>
    object as a parameter. <br />
    Specifying a proper set of handlers is generally advised. The handlers will form the first line of error detection and
    processing system. Error handlers should check if the response from the server contains any
    <span class="code">&lt;Fault&gt;</span> or <span class="code">&lt;Error&gt;</span> elements and if so, they should prevent
    it from being processed. Any additional message check can be performed. After ensuring the message is valid,
    the normal content processing flow may be continued.
    <br /><br />
    There is a situation when specifying a handler is mandatory. It is when a message going in or out
    contains a <span class="code">mustUnderstand="1"</span> attribute value. Each such message must be handled in the proper way,
    or <span class="code">org.apache.axis2.AxisFault</span> will be thrown. To avoid this and ensure correct
    <span class="code">mustUnderstand="1"</span> handling, the following step must be taken:
    <ul>
        <li>
            The <span class="code">setProcessed()</span> method must be invoked on each of the <span class="code">SOAPHeaderBlock</span>
            members of the <span class="code">SOAPHeader</span> element of the current context.
        </li>
    </ul> <br />
    The example flow may look something like this:

<p class="snippet">
    SOAPHeader header = msgContext.getEnvelope().getHeader(); <br />
    Iterator headerBlocksIterator = header.getHeadersToProcess(null); <br /><br />
    while( headerBlocksIterator.hasNext() ) { <br />
    &emsp;&emsp;SOAPHeaderBlock headerBlock = (SOAPHeaderBlock) headerBlocksIterator.next(); <br />
    &emsp;&emsp;// process header block <br />
    &emsp;&emsp;headerBlock.setProcessed();<br />
    }<br />
</p>

</p>
<hr />
<span class="section">1.1.1 ADB data binding </span> <br /><br />
<span class="bold"> Overview </span> <br />

<p> ADB data binding framework is intended to be rather simple and lightweight. It provides means to compile XML schemas and WSDL files into java classes. 
Use of this tool is pretty straightforward, but working with generated files may be cumbersome. </p>

<span class="bold">Using ADB data binding </span> <br />
 
<p> ADB data binding is generally available through the <span class="code">WSDL2Java</span> tool, by specifying proper databinding option, as described
    in Axis2 section <!-- TODO: add link -->.

</p>
<span class="bold">Execution requirements</span>

<p> As Sabre Web Services definitions (provided in the form of WSDL files) use corresponding types of data structures, proper XML Schema files must be provided in same location as the WSDL file.
It includes common schemas for SOAP communication protocol (available as Common Schemas asset at <a href="https://drc.sabre.com/">https://drc.sabre.com/</a> ) and request/response object pairs definition 
(available also at <a href="https://drc.sabre.com/">https://drc.sabre.com/</a> as asset for each service or at
    <a href="http://developer.sabre.com">http://developer.sabre.com</a>). </p>

<span class="bold">Generated code</span>

<p> If all of the required files are available for code generation tool, after invocation it will by default generate one
    stub java class per service.
    The file will be placed in proper folder structure, according to specified output package and directory.
    The file will be named <span class="code"> &lt;serviceName&gt;ServiceStub.java </span>
    The stub will contain static inner classes for each complex type. Any element or attribute encapsulated by this complex type
    will become a field in that class. Simple types restrictions are handled by replacing the relevant type with the basetype.
    Generated classes follow the bean convention, with <span class="code">setAttribute</span> and
    <span class="code">getAttribute</span> methods for object fields and
    <span class="code">addElement(Element e)</span> or <span class="code">setElements(Element [] e)</span> for arrays.
</p>

<span class="bold">Limitations and drawbacks</span> <span class="warning">(important)</span>
<p>
    Generated files may be quite large (up to hundreds of thousands of lines, depending on service definition complexity ) and therefore
    problematic to work with, for example some IDE settings changes may be necessary. <br />
    What is more, ADB does not handle optional attributes in schema definitions well. In generated SOAP messages optional
    attributes are always present, with values set to their defaults, which may not be desired behavior. In particular cases
    optional attributes may be mutually exclusive and sending request containing them to server may cause the server
    to respond with Fault message. <br />
    Therefore it might not be possible to use automatically generated code without modificating it manually. <br /><br />
    Nevertheless, using ADB causes significant code redundancy in project. The reason is the fact that all binding inner
    classes are generated per service. So there is one inner class for eb:MessageHeader xml object and one for wsse:Security
    in each service, even though the structure of these classes is identical, as they reflect the same source xml structure.
    For each service request an object of those classes must be assembled. So either a separate header-creating method must
    be implemented for each service stub causing code repetition, or a header factory method using reflection
    and generic return type may be introduced, which would be difficult and error-prone. <br/><br />
    Because of the facts mentioned above, <span class="warning">ADB is not a recommended databinding framework
    for working with Sabre Web Services.</span>
</p>
<hr />
<span class="section">1.1.2 XMLBeans data binding </span> <br /><br />
<span class="bold"> Overwiev </span> <br /><br />

<p>
    XMLBeans is another data binding framework for Java. It also is available via <span class="code">wsdl2code</span> maven plugin.
    In this case, classes are not generated per service, but rather per namespace. It eliminates the code duplication problem,
    causing code to be clearer and easier to use. <br />
    However, XMLBeans framework has another significant problem, which may cause it impossible to use with some of the
    Sabre Web Services (described in separate section). One should keep that in mind when deciding to use XMLBeans,
    because at some point being unable to consume specific Sabre Web Service may block development of whole application.
</p>

    <span class="bold">Using XMLBeans</span>

<p>
    Just like ADB, XMLBeans data binding is available in Axis2 via <span class="code">WSDL2Java</span> command line tool
    or <span class="code">wsdl2code</span> Maven plugin. They both provide same functionality and require similar
    configuration.

</p>

    <span class="bold">Execution requirements</span>

<p>
    As XMLBeans framework is invoked as part of Axis2 client generation, for data binding purposes, the flow is similar to
    the one described in ADB section. The main (and in most cases, the only) change would be to change the data binding option
    (the <span class="code">-d xmlbeans</span> command line option or
    <span class="code">&lt;databindingName&gt;xmlbeans&lt;/databindingName&gt;</span> in Maven configuration).
    Any additional files referenced from WSDL file must reside with it in it's directory.
</p>


<span class="bold">Generated code</span>

<p>
    XMLBeans will generate one stub class per service (one stub class per one WSDL file). That stub will encapsulate
    methods for invoking service calls defined in WSDL file. Unlike ADB, XMLBeans will generate classes per
    XML structure namespace, which means one class for <span class="code">eb:MessageHeader</span> and
    one class for <span class="code">wsse:Security</span>. Creating these objects can be done globally and the
    proper factory method may be reused in every service. <br /><br />

    The structure of generated classes will mirror the structure of XSD schema definition. Each nested type
    in schema will cause the creation of corresponding nested Java Interface. That will cause problem described in the next section.
    <br /><br />

    Generated interfaces will be placed in a package whose name will reflect the target namespace of schema definition.
    The general rules for converting namespace to package name can be obtained from
    <a href="http://xmlbeans.apache.org/docs/2.0.0/guide/conJavaTypesGeneratedFromUserDerived.html">XMLBeans documentation</a>.<br /><br />

    XMLBeans maps schema types into JavaBeans-style classes. This means the presence of typical setter/getter methods, such as
    <span class="code">void setElement(ElementType element)</span> and <span class="code">ElementType getElement()</span>.
    One useful thing is also a <span class="code">ElementType addNewElement()</span> method, that creates new element, places
    it in the object in which it was invoked and returns it allowing further modification and processing. <br /> <br />

    One can learn about using XMLBeans at <a href="http://xmlbeans.apache.org/documentation/index.html">XMLBeans Project's website</a>
</p>


<span class="bold">Limitations and drawbacks</span> <span class="warning">(important)</span>

<p>
    Although using XMLBeans data binding results in more clear and easy-to-use code, it has a serious issue,
    which cause it almost impossible to use with some of the Sabre Web Services. <br /> <br />

    To reflect the structure of XML Schema Definition, XMLBeans creates a series of nested interfaces.
    Each nested type will have a corresponding nested interface. The problem is, that at compile time the Java compiler
    creates separate <span class="code">.class</span> file for each class or interface. Nested classes will be compiled
    to a file whose name will be composed of the name of the outer class, concatenated with the name of the inner class
    with the dollar symbol ('$'). Classes nested in inner classes will be compiled to a file whose name will be composed of the
    names of all classes which are higher in the hierarchy, like
    <span class="code">OuterClass$InnerClass1$InnerClass2$...$InnerClass10$InnerClass11.class</span>.
    When generating classes from a complex schema with deeply nested types, generated class's name may exceed the 255
    characters limit imposed by most of the modern filesystems, used in both Windows and Unix-like systems
    (this limit is present in all of the following file systems: NTFS, FAT32, exFAT, ext3, ext4 and ZFS). This will
    make such nested class/interface impossible to compile, as the Java compiler will not be able to save compiled
    file on disk. There is no possibility to use any custom binding or change XMLBeans behavior in way that would
    allow generating Java stubs from deeply nested schemas. Therefore it is not possible to use XMLBeans with some of
    the Sabre Web Services, that contain deeply nested schemas (e.g. EnhancedAirBook, PassengerDetailsRQ, TravelItineraryLLSRQ),
    when using any common file system. On the other hand, changing operating system or switching to niche filesystem
    just to use one particular XML binding framework (while there are many others) seems to be an exaggeration. <br /><br />

    For the record, it should be mentioned that there is actually a way to use XMLBeans on any common filesystem
    and avoid long file names issue. However, it is a workaround that requires developing specialized tools,
    like custom compilers or Maven plugins, that should be next incorporated into application build process.
    The trick is, that JVM itself does not preserve the 255 characters identifier length limit (it uses
    it's own 65535 characters limit), so the only problem is a intermediate step of storing .class file on disk
    between compiling and loading class by a classloader. Therefore, avoiding this step, would solve the problem.
    There are at least two possible ways to do that. They both make use of the <span class="code">javax.tools</span>
    package. The first way is to create a custom dynamic in-memory java compiler, that would load a source code file
    from the disk, compile it in-memory and then provide means of instantiating object of compiled class via
    customized in-memory classloader. Another way is to compile problematic source code in-memory and redirect the output
    to byte arrays, which then would be used to create a JAR containing created classes. That way the storing phase would
    be omitted, as the only file written to filesystem would be the JAR, which holds no name limitations. <br />
    Although those ways seem to solve the problem (they were not tested), once again, creaing custom compilers
    and classloaders does not seem to be an adequate way of solving a problem caused by wrong choice of
    data binding framework for web services application.<br/><br />

    Because of the facts mentioned above, <span class="warning">XMLBeans is not a recommended databinding framework
    for working with Sabre Web Services neither.</span>
</p>

<br /><hr /> <br />

<span class="subheader">1.2. Apache CXF</span>

<p>
    Apache CXF is another framework designed strictly for the purpose of working with web services.
    In general, it provides same functionality as Axis2, which means the ability to send, process and receive messages,
    both to and from services. Similarly, CXF allows user to develop both client and server side application.
    It uses contract-first approach, which means creation of service implementation code based on service definition
    (in form ow WSDL files and schema definition). What it means for Sabre Web Services consumer, is that Java client
    code can be generated easily based on WSDL and XSD files, available on <a href="https://drc.sabre.com">DRC</a> and
    <a href="http://developer.sabre.com">Developer's Site</a>.
    <br />
    Client code will consist of classes similar to service stubs in Axis2, Services and PortTypes, allowing
    user to invoke services calls, and accompanying binding classes representing types defined in schemas.
    Developer's role is to construct an object representing request to be invoked, pass it to a method representing
    service call, and then to process the response.
</p>

<span class="bold">Using CXF</span> <br />

<p>

    CXF's code generation feature may be used in one of three ways: <br />

    <ul>
        <li>As command line tool</li>
        <li>As Maven goal</li>
        <li>Via WSDL2Java API at runtime</li>
    </ul>

    The documentation for command line tool can be obtained <a href="http://cxf.apache.org/docs/wsdl-to-java.html">here</a>,
    and maveen plugin documentation is available <a href="http://cxf.apache.org/docs/using-cxf-with-maven.html#UsingCXFwithmaven-MavenPlugin">here</a>
    and <a href="http://cxf.apache.org/docs/maven-cxf-codegen-plugin-wsdl-to-java.html">here</a>.

</p>

<span class="bold">Typical CXF flow</span> <br />

<p>
    Using CXF to consume web services is generally no different than using CXF:

    <ol>
        <li>Collecting all necessary files (WSDL, XML and XSD) for each service</li>
        <li>Generating services stubs code, using one of the data binding frameworks (e.g. XMLBeans, JAXB)</li>
        <li>Creating client, which will use generated code</li>
        <li>Providing interceptors for messages</li>
        <li>Invoking services via adequate methods calls</li>
        <li>Receiving and handling the response</li>
    </ol>

</p>

<span class="bold">Developing client in detail</span> <br />

<p>
    Client development starts with collecting services definitions and schema definitions (WSDL and XSD) files.
    They are available for Sabre clients on web. Note, that code generation tool expect all the necessary schemas
    to be present in the same directory as WSDL file. So be sure to place there not only the service specific files,
    but also those available as "Common Schemas" asset (they are needed to create SOAP envelope and message correctly).
    <br /><br />
    When required files are gathered, <span class="code">wsdl2java</span> tool can be used to generate client code.
    Check documentation mentioned before for details on how to use this tool.
    <br /><br />
    On this stage, developer must decide which data binding framework to use for client code generation. The recommended
    one is JAXB, as it is quite easy to use and elastic, yet powerful. The ADB and XMLBeans frameworks have disadvantages
    described in previous sections. However, the proper use of JAXB data binding requires taking additional steps
    (creating custom binding files), as described in next section. However, this is not difficult thing to do.
    <br /><br />
    The next step is to create a client, which will utilize generated classes to access web services.
    This process requires a bit of knowledge how the CXF framework works. This will be covered here briefly. To see
    a full working example, please refer to the !!!sample project, provided by Sabre Web Services Team (toolkit-cxf-jaxb module).
    <br /><br />
    CXF generates two main classes for each service defined in WSDL file:
    <span class="code">&lt;ServiceName&gt;Service extends javax.xml.ws.Service</span> and
    <span class="code">&lt;ServiceName&gt;PortType</span>.
    <br /><br />
    The first one provides two useful components:
    <ul>
        <li>Default constructor - creates service class, based on information contained in WSDL file at the time
        of generating this class (assumes, that WSDL file is still available in the same location)</li>
        <li><span class="code">get_PortName_()</span> method - returns a class associated with specific
        port defined in service. This class maps each operation defined in the WSDL file to a corresponding method,
        whose invokation is equivalent to a web service call.</li>
    </ul>
    So, based on !!!sample project, the invokation of Sabre's OTA_AirAvailLLSRQ would look something like this:
    <br /><br />
    <span class="code">
        &emsp;&emsp;OTAAirAvailService service = new OTAAirAvailService(); <br />
        &emsp;&emsp;OTAAirAvailPortType port = service.getOTAAirAvailPortType(); <br />
        &emsp;&emsp;OTAAirAvailRS serviceResponse = port.otaAirAvail(...); // set correct arguments <br />
    </span>
    <br />

    After creating logic to create requests and handle respones, one must define interceptors for services. Interceptors
    are necessary to get access to full SOAP envelope. Invoking methods on port class allows only to see response body,
    which is not enough information to successfully consume Sabre Web Services. Typically, one has to access the
    data in SOAP header, like <span class="code">&lt;eb:MessageHeader&gt;</span>
    (<span class="code">eb:Action</span> element, to check if the message contains correct or error response)
    and <span class="code">&lt;wsse:Security&gt;</span> (to obtain binary security token during session creation).
    Interceptors allow exactly to do that.
    <br/>
    In the !!!sample project, interceptor classes are derived from
    <span class="code">org.apache.cxf.binding.soap.interceptor.SoapActionInInterceptor</span> class, which
    provides means of accessing full SOAP message via <span class="code">handleMessage(SoapMessage message)</span> method.
    It is possible to get full information from SOAP message as stream, however, this will leave the message empty.
    To avoid error on further processing, data must be copied and placed back into the message
    (see <span class="code">LLSErrorInterceptor</span> class from
    <span class="code">com.sabre.sws.tools.wsdl.cxf.jaxb.interceptors</span> package in
    <span class="code">toolkit-cxf-jaxb</span> module in !!!sample project).
    Interceptor must be placed in a correct phase, so that the expected data is present in the message as it is being processed.
    For the detailed information about phases and interceptor chains, please refer to the
    <a href="http://cxf.apache.org/docs/interceptors.html"> CXF's documentation</a>.
    <br /><br />
    Note one important thing - by default, port class will use the endpoint URL specified in WSDL file, from which
    it was created. However, this could be highly undesirable, especially during the development and testing phase,
    as this would be <span class="code">https://webservices.sabre.com/websvc</span> - it's a production endpoint and
    performing any operations on it may generate charges on customer's account and decrement real-time inventory.
    During development, one would probably use Sabre test system or even mocked service. To change endpoint URL
    used by your service's client, please do as following (or see one of classes in
    <span class="code">com.sabre.sws.tools.wsdl.cxf.jaxb.wrappers</span> package in !!!sample project):
    <br /><br />

    <span class="code">
    &emsp;&emsp;String endpointURL = "http://some.test.url/svc"; <br />
    &emsp;&emsp;OTAAirAvailService service = new OTAAirAvailService(); <br />
    &emsp;&emsp;OTAAirAvailPortType port = service.getOTAAirAvailPortType(); <br />
    &emsp;&emsp;BindingProvider bindingProvider = (BindingProvider) port;<br />
    &emsp;&emsp;bindingProvider.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY, endpointURL);<br />
    </span>

    <br /><br />
    After all these steps are taken, one has to create a valid request object and pass it to port's method corresponding
    to the desired service, along with proper header holders (as in the !!!sample project).
    The method will return response object, which may be further processed to extract required information from it.
</p>

    <span class="bold">Known issues</span>

    <br /><br />

    There are some extra steps that must be taken in order build Sabre Web Services' client using CXF and JAXB.
    <br /><br />
    JAXB generates a public static class for each complex type defined in a schema. Due to that, if two (or more) types
    with the same name will appear in a schema, there will be two public static classes with the same name in one outer
    class, which is illegal and will cause compilation error. To solve that, one must define custom JAXB binding which
    will change one of the clashing names. Binding files are provided as parameters during code generation.
    Binding contains schema file location, node position (in the form of XPath expression) and desired class name.
    Simple adding number to the node name will solve the problem without reducing readability of the resulting code.
    <br /><br />
    This approach has one disadvantage - binding should specify the location of the schema file, which it concerns.
    It means hardcoding that location into binding file and may cause troubles, when location or name of the file changes
    (eg. project starts to use newer version of the service). There is no simple solution to this and one should keep that
    in mind when manipulating with schema files or project structure.
    <br /><br />
    To see working example of binding use, refer to the !!!sample project.

</body>
</html>
